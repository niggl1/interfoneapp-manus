// Prisma Schema para InterfoneApp
// Documentação: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ==================== ENUMS ====================

enum UserRole {
  ADMIN       // Administrador do sistema
  MANAGER     // Síndico/Administrador do condomínio
  JANITOR     // Zelador
  RESIDENT    // Morador
}

enum UserStatus {
  ACTIVE
  INACTIVE
  PENDING
}

enum CallStatus {
  RINGING
  ANSWERED
  MISSED
  REJECTED
  ENDED
}

enum CallType {
  VIDEO
  AUDIO
}

enum MessageStatus {
  SENT
  DELIVERED
  READ
}

enum ChatType {
  DIRECT        // Chat direto entre 2 pessoas
  GROUP         // Chat em grupo (condomínio)
  VISITOR       // Chat com visitante
  SUPPORT       // Chat com portaria/suporte
}

// ==================== MODELS ====================

// Condomínio
model Condominium {
  id          String   @id @default(uuid())
  name        String
  address     String
  city        String
  state       String
  zipCode     String
  phone       String?
  email       String?
  qrCode      String?  @unique // QR Code geral do condomínio
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  blocks      Block[]
  users       User[]
  announcements Announcement[]
  chatRooms   ChatRoom[]

  @@map("condominiums")
}

// Bloco/Torre
model Block {
  id            String   @id @default(uuid())
  name          String   // Ex: "Bloco A", "Torre 1"
  condominiumId String
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  condominium   Condominium @relation(fields: [condominiumId], references: [id], onDelete: Cascade)
  units         Unit[]

  @@map("blocks")
}

// Unidade/Apartamento
model Unit {
  id        String   @id @default(uuid())
  number    String   // Número do apartamento
  floor     Int?     // Andar
  blockId   String
  qrCode    String?  @unique // QR Code específico da unidade
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  block     Block    @relation(fields: [blockId], references: [id], onDelete: Cascade)
  residents User[]

  @@unique([blockId, number])
  @@map("units")
}

// Usuário (Morador, Zelador, Admin)
model User {
  id            String     @id @default(uuid())
  email         String     @unique
  password      String
  name          String
  phone         String?
  avatar        String?    // URL da foto
  role          UserRole   @default(RESIDENT)
  status        UserStatus @default(PENDING)
  condominiumId String?
  unitId        String?    // Apenas para moradores
  pushToken     String?    // Token FCM para notificações
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt

  condominium   Condominium? @relation(fields: [condominiumId], references: [id], onDelete: SetNull)
  unit          Unit?        @relation(fields: [unitId], references: [id], onDelete: SetNull)
  
  // Relacionamentos de chamadas
  callsMade     Call[]       @relation("CallCaller")
  callsReceived Call[]       @relation("CallReceiver")
  
  // Relacionamentos de mensagens (legado)
  messagesSent     Message[] @relation("MessageSender")
  messagesReceived Message[] @relation("MessageReceiver")
  
  // Relacionamentos de chat
  chatRoomMembers  ChatRoomMember[]
  chatMessages     ChatMessage[]
  
  // Tokens de refresh
  refreshTokens RefreshToken[]
  
  // Tokens de recuperação de senha
  passwordResets PasswordReset[]
  
  // Função "Estou Chegando"
  pin           UserPin?
  vehicles      Vehicle[]
  arrivalNotices ArrivalNotice[]
  
  // Convites criados pelo morador
  invitations   Invitation[]
  
  // Notificações
  notifications Notification[]

  @@map("users")
}

// Token de recuperação de senha
model PasswordReset {
  id        String   @id @default(uuid())
  token     String   @unique
  userId    String
  expiresAt DateTime
  used      Boolean  @default(false)
  createdAt DateTime @default(now())

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("password_resets")
}

// Token de Refresh para autenticação
model RefreshToken {
  id        String   @id @default(uuid())
  token     String   @unique
  userId    String
  expiresAt DateTime
  createdAt DateTime @default(now())

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("refresh_tokens")
}

// Registro de Chamadas
model Call {
  id         String     @id @default(uuid())
  callerId   String?    // Pode ser null para visitantes
  receiverId String
  callerName String?    // Nome do visitante (quando não é usuário)
  callerType String     @default("user") // "user" ou "visitor"
  type       CallType   @default(VIDEO)
  status     CallStatus @default(RINGING)
  startedAt  DateTime   @default(now())
  answeredAt DateTime?
  endedAt    DateTime?
  duration   Int?       // Duração em segundos

  caller     User?      @relation("CallCaller", fields: [callerId], references: [id], onDelete: SetNull)
  receiver   User       @relation("CallReceiver", fields: [receiverId], references: [id], onDelete: Cascade)

  @@map("calls")
}

// Mensagens (legado - mantido para compatibilidade)
model Message {
  id         String        @id @default(uuid())
  senderId   String
  receiverId String
  content    String
  status     MessageStatus @default(SENT)
  createdAt  DateTime      @default(now())
  readAt     DateTime?

  sender     User          @relation("MessageSender", fields: [senderId], references: [id], onDelete: Cascade)
  receiver   User          @relation("MessageReceiver", fields: [receiverId], references: [id], onDelete: Cascade)

  @@map("messages")
}

// ==================== SISTEMA DE CHAT ====================

// Sala de Chat
model ChatRoom {
  id            String    @id @default(uuid())
  name          String?   // Nome do grupo (para chats em grupo)
  type          ChatType  @default(DIRECT)
  condominiumId String?   // Para chats de condomínio
  isActive      Boolean   @default(true)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  // Para chat com visitante
  visitorName   String?
  visitorPhone  String?
  
  condominium   Condominium? @relation(fields: [condominiumId], references: [id], onDelete: Cascade)
  members       ChatRoomMember[]
  messages      ChatMessage[]

  @@map("chat_rooms")
}

// Membros da Sala de Chat
model ChatRoomMember {
  id         String   @id @default(uuid())
  chatRoomId String
  userId     String
  isAdmin    Boolean  @default(false) // Admin do grupo
  joinedAt   DateTime @default(now())
  leftAt     DateTime?
  lastReadAt DateTime? // Última vez que leu as mensagens
  
  chatRoom   ChatRoom @relation(fields: [chatRoomId], references: [id], onDelete: Cascade)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([chatRoomId, userId])
  @@map("chat_room_members")
}

// Mensagens do Chat
model ChatMessage {
  id         String        @id @default(uuid())
  chatRoomId String
  senderId   String?       // Null para mensagens do sistema ou visitante
  content    String
  type       String        @default("text") // text, image, audio, system
  status     MessageStatus @default(SENT)
  
  // Para mensagens de visitante (quando senderId é null)
  senderName String?
  
  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @updatedAt
  
  chatRoom   ChatRoom      @relation(fields: [chatRoomId], references: [id], onDelete: Cascade)
  sender     User?         @relation(fields: [senderId], references: [id], onDelete: SetNull)

  @@map("chat_messages")
}

// Comunicados/Avisos
model Announcement {
  id            String   @id @default(uuid())
  title         String
  content       String
  condominiumId String
  authorId      String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  condominium   Condominium @relation(fields: [condominiumId], references: [id], onDelete: Cascade)

  @@map("announcements")
}

// ==================== FASE 2 (Preparado, não exposto) ====================

// Dispositivo IoT para controle de acesso
model AccessDevice {
  id            String   @id @default(uuid())
  name          String   // Ex: "Portão Principal"
  condominiumId String
  protocol      String   // "REST" ou "MQTT"
  endpoint      String   // URL ou tópico MQTT
  method        String?  // GET, POST (para REST)
  headers       Json?    // Headers customizados
  body          Json?    // Body da requisição
  isActive      Boolean  @default(false) // Desativado até Fase 2
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@map("access_devices")
}

// Log de acessos físicos
model AccessLog {
  id         String   @id @default(uuid())
  deviceId   String
  userId     String?
  action     String   // "open", "close"
  success    Boolean
  createdAt  DateTime @default(now())

  @@map("access_logs")
}


// ==================== FUNÇÃO "ESTOU CHEGANDO" ====================

enum ArrivalStatus {
  PENDING     // Aviso enviado, aguardando confirmação do porteiro
  CONFIRMED   // Porteiro confirmou recebimento
  ARRIVING_500M // Morador a 500m
  ARRIVING_200M // Morador a 200m
  ARRIVING_50M  // Morador a 50m
  ARRIVED     // Morador chegou
  CANCELLED   // Aviso cancelado
}

enum TransportType {
  OWN_VEHICLE   // Veículo próprio cadastrado
  UBER_TAXI     // Uber, 99, Taxi, etc.
  ON_FOOT       // A pé
  OTHER         // Outro
}

// PIN de segurança do usuário
model UserPin {
  id        String   @id @default(uuid())
  userId    String   @unique
  pin       String   // PIN criptografado (4-6 dígitos)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_pins")
}

// Veículos do morador
model Vehicle {
  id        String   @id @default(uuid())
  userId    String
  plate     String   // Placa do veículo
  model     String   // Modelo (ex: "Honda Civic")
  color     String?  // Cor do veículo
  isDefault Boolean  @default(false) // Veículo padrão
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  arrivals  ArrivalNotice[]

  @@map("vehicles")
}

// Aviso de chegada
model ArrivalNotice {
  id            String        @id @default(uuid())
  userId        String
  vehicleId     String?
  condominiumId String
  status        ArrivalStatus @default(PENDING)
  
  // Tipo de transporte
  transportType TransportType @default(OWN_VEHICLE)
  
  // Dados do Uber/Taxi (quando transportType = UBER_TAXI)
  rideVehiclePlate String?    // Placa do veículo
  rideVehicleModel String?    // Modelo (ex: "Onix Preto")
  rideVehicleColor String?    // Cor do veículo
  rideDriverName   String?    // Nome do motorista (opcional)
  
  // Localização
  latitude      Float?
  longitude     Float?
  lastLocationAt DateTime?
  
  // Timestamps
  createdAt     DateTime      @default(now())
  confirmedAt   DateTime?     // Quando o porteiro confirmou
  arrivedAt     DateTime?     // Quando o morador chegou
  cancelledAt   DateTime?
  
  // Relacionamentos
  user          User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  vehicle       Vehicle?      @relation(fields: [vehicleId], references: [id], onDelete: SetNull)

  @@map("arrival_notices")
}


// ==================== CONVITES ====================

enum InvitationStatus {
  ACTIVE      // Convite ativo
  USED        // Convite já utilizado
  EXPIRED     // Convite expirado
  CANCELLED   // Convite cancelado pelo morador
}

// Convite para visitante
model Invitation {
  id            String           @id @default(uuid())
  code          String           @unique // Código único do convite (ex: INV-XXXXXX)
  hostId        String           // Morador que criou o convite
  unitId        String           // Unidade do morador
  condominiumId String           // Condomínio
  
  // Dados do visitante esperado
  visitorName   String           // Nome do visitante
  visitorPhone  String?          // Telefone do visitante (opcional)
  visitorEmail  String?          // Email do visitante (opcional)
  
  // Configurações do convite
  validFrom     DateTime         @default(now()) // Início da validade
  validUntil    DateTime         // Fim da validade
  maxUses       Int              @default(1) // Número máximo de usos
  usedCount     Int              @default(0) // Quantas vezes foi usado
  
  // Observações
  notes         String?          // Observações do morador
  
  // Status
  status        InvitationStatus @default(ACTIVE)
  
  // Timestamps
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt
  usedAt        DateTime?        // Última vez que foi usado
  
  // Relacionamentos
  host          User             @relation(fields: [hostId], references: [id], onDelete: Cascade)
  usages        InvitationUsage[]

  @@map("invitations")
}

// Registro de uso do convite
model InvitationUsage {
  id           String     @id @default(uuid())
  invitationId String
  usedAt       DateTime   @default(now())
  
  // Dados capturados no uso
  visitorName  String?    // Nome informado pelo visitante
  visitorPhone String?    // Telefone informado
  
  // Relacionamentos
  invitation   Invitation @relation(fields: [invitationId], references: [id], onDelete: Cascade)

  @@map("invitation_usages")
}


// ==================== NOTIFICAÇÕES ====================

enum NotificationType {
  INVITATION_USED   // Convite foi utilizado
  CALL_MISSED       // Chamada perdida
  CALL_RECEIVED     // Chamada recebida
  ANNOUNCEMENT      // Novo comunicado
  CHAT_MESSAGE      // Nova mensagem de chat
  SYSTEM            // Notificação do sistema
}

// Notificação
model Notification {
  id        String           @id @default(uuid())
  userId    String           // Usuário que recebe a notificação
  type      NotificationType
  title     String
  body      String
  data      Json?            // Dados adicionais (ex: invitationId, callId)
  read      Boolean          @default(false)
  readAt    DateTime?
  createdAt DateTime         @default(now())
  
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notifications")
}
